# 4장 변수
### String 
 String 만이, 참조자료형이면서 new 를 사용해서 객체 생성을 하지 않아도 되는 유일한 타입 

### char 
정수형에서 유일하게 부호가 없는 자료형

char 값 지정
1. 'A'와 같이 직접 홑따옴표에 입력
2. '\u1188' 처럼 \u 와 4개의 16진수 값 입력
3. 해당 값의 유니코드 입력 

```java
char charMin = '\u0000';
char charMax = '\uffff'
```

> 결과 
>charMin = [ ]  // 실제 공백이 출력
>charMax =[?]


### double & float 
각 64,32 비트, 제공할 수 있는 범위를 넘어가면 정확성 보장 못 함. 
-> 정확한 계산이 요구될 때에는 BigDemical 클래스 사용

### **정리해봅시다**

1. 인스턴스 변수, 클래스 변수, 지역 변수, 매개 변수 
2. 변수의 이름은 소문자로 시작해야 한다. 
3. 자료형은 기본 자료형, 참조 자료형이 있다. 
4. 기본 자료형은 정수형 byte, char, short, int, long / 소수형 float, dobule/ boolean 가 있다.
5. byte는 8비트다.
6. byte는 왜 만들어졌나요? - 답 찾기 
7. long 은 int 형보다 더 많은 데이터를 다룬다. -2^63 ~ 2^63 -1


모든 참조 자료형은 초기화 하지 않으면 nul
각 배열의 크기만 설정해주면, 초기화 하지 않아도 각 배열의 기본값이 할당
참조자료형은 toString() 메서드가 없으면, 타입이름@고유번호가 출력



# 6장 조건문
String 은 + 연산이 가능하다. 
|| 와 && 중 && 의 우선순위가 더 높다. 

# 8장 참조 자료형

```java
public void print(String content, int number)
public void print(int number, String content)
```
서로 다른 메서드로 인식(오버로딩) _ 순서만 달라도 ok 

- return 뒤에 아무것도 없이 바로 세미콜론(;) 적어주면, 메소드 수행을 바로 종료한다. 
-  static 메서드는 클래스 변수만 사용할 수 있다. 
- 한 번만 호출되어야 하는 코드가 있다면 "static 블록"을 사용하면 된다.
### pass by value VS pass by reference
- pass by value : 값만 전달한다. 매개변수를 받은 메서드에서 값을 변경해도 원래의 값은 변하지 않는다. 
- 참조자료형은 pass by reference, but 호출된 메서드에서 다른 객체로 대체하여 처리하면 기존 값은 변하지 않는다. 

```java
String a = "a";
System.out.println("(1) a : " + a); 
public void function1(String a){
	a = "b";
	System.out.println("(2) a : " + a); 
}
System.out.println("(3) a : " + a); 
```
> 결과 
> a : a
> a : b
> a : a 



### 타입...변수명 
```java
public void calculateNumber(int...numbers){
	int total = 0; 
	for(int number:numbers){
		total += number;
	}
}
```
- 하나의 메소드에서 한 번만 사용 가능 
- 여러 매개 변수가 있다면, 가장 마지막에 선언해야함.




# 9장 접근제어자
# 10장 상속

- 자식 클래스의 생성자가 호출되면, 자동으로 부모 클래스이 매개 변수 없는 생성자가 실행된다. 
- 참조 자료형도 형 변환이 가능하다. 
- 자식 타입의 객체를 부모 타입으로 형변환 하는 것은 자동으로 된다. 
- 부모 타입의 객체를 자식 타입으로 형 변환 할 때에는 명시적으로 타입을 지정해 주어야 한다. 부모 타입의 실제 객체는 자식 타입이어야 한다. 
- instanceof로 타입 확인 할 때 부모 타입도 true 결과를 반환한다. 
- 부모 클래스에 선언된 변수와 동일한 이름을 가진 변수를 선언이 가능하나 권장하지 않는다. 
## super
- 메서드처럼(super()) 사용하면 부모클래스의 생성자를 호출
- super.print() 처럼 사용하면 부모 클래스에있는 print() 메서드를 호출 
- 자식 클래스 생성자에서 super()를 명시적으로 지정하지 않으면, 컴파일시 자동생성
- 부모 클래스의 생성자를 호출하는 super()느 반드시 자식 클래스 생성자에서 가장 첫줄에 선언되어야 한다. 
## 오버라이딩
- 자식 클래스에서 오버라이딩 하는 메서드의 리턴타입은 바꿀 수 없다. 
- 부모 클래스보다 더 강한 접근제어자( 범위가 좁은 )를 사용하면 안된다.
ex) 부모가 public 인데 자식이 private 일 수 없음 , but 부모가 private 면 자식은 모든 접근제어자 사용 가능 
## 다형성
> 형변환을 하더라도 실제 호출되는 것은 원래 객체에 있는 메소드이다. 


# 11장 API 공식 문서
# 12장 Object 클래스 
- String 을 제외한 참조 자료형에 더하기 연산을 수행하면, 자동으로 toString() 메소드가 호출된다. 
- Overriding 하지 않으면 equlas() 메소드에서 hashCode() 값을 비교한다. 
- equals() 메소드를 오버라이딩 할 때에는 hashCode() 메소드도 같이 오버라이딩 해야함.
- hashCode() 는 객체의 메모리 주소를 16진수로 리턴

### HashCode() 오버라이딩 조건 
1. 자바 어플리케이션 수행 동안 어떤 객체에 대해서 이 메소드가 호출될 때에는 항상 동일한 int 값을 리턴해줘야한다. (실행할 때마다 같은 값이어야 할 필요는 없다.)
2. 어떤 두 개의 객체에 대해 equals()가  true면, hashCode() 도 동일한 int 값을 리턴해야한다.
3. 두 객체를 equals() 한 값이 false 라고 해서 hashCode()의 리턴값이 무조건 달라야 할 필요는 없다. 그러나 이 경우 서로 다른 int 값을 제공하면 hashTable의 성능을 향상시키는데 도움이 된다. 

# 13장 인터페이스, 추상클래스, enum

## 인터페이스, 추상클래스 사용 이유
- 설계시 선언해 두면 개발할 때 기능을 구현하는데만 집중할 수 있다.
- 개발자의 역량에 따른 메소드의 이름과 매개변수 선언의 격차를 줄일 수 있다.
- 공통적인 인터페이스와 abstract 클래스를 선언해두면, 선언과 구현을 구분할 수 있다. 




final 이 붙은 클래스는 상속할 수 없다.
-> 더 이상 확장해서는 안 되는 클래스, 상속 받아서 변경해서는 안되는 클래스 선언시 사용

