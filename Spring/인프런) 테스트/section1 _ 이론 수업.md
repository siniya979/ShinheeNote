

# 테스트의 필요성과 테스트 3분류

## **필요성** 
레거시 코드란, 단순히 테스트 루틴이 없는 코드다.  ( 마이클 C.페더스 )
잘 돌아가던 코드가 배포로 인해 동작하지 않는 상황을 Regression이라 한다. 

**테스트와 SOLID는 상호 보완적이다.** 
![](https://i.imgur.com/zzKEqBY.png)


**S : Single Responsibility principle 단일 책임 원칙**
테스트는 명료하고 간단하게 작성해야하기 때문에, 단일 책임 원칙을 지키게 된다. 
테스트가 너무 많아져서 이게 무슨 목적의 클래스이니 눈에 안들어오는 지점이 생긴다.
이 때가 클래스를 분할해야 하는 시점, 그러면서 책임이 자연스럽게 분배 된다. 

**O : Open/Closed principle 개방 폐쇄 원칙** 
테스트 컴포넌트와 프로덕션 컴포넌트를 나눠 작업하게 되고 필요에 따라 이 컴포넌트를 자유자재로 탈부착이 가능하도록 개발하게 된다. 

**L : Liskov Subsitution principle 리스코프 치환 원칙** 
즉 슈퍼 클래스의 계약을 서브 클래스가 제대로 치환하고 있는지 확인하라! 
이상적으로 테스트는 모든 케이스에 대해 커버하고 있으므로, 서브 클래스에 대한 치환 여부를 테스트가 알아서 판단해준다. 

**I : Interface segregation principle 인터페이스 분리 원칙** 
테스트는 그 자체로 인터페이스를 직접 사용해볼 수 있는 환경. 불필요한 의존성을 실제로 확인할 수 있는 샌드박스 
 
**D : Dependency Inversion principle 의존성 역전 원칙** 
가짜 객체를 이용하여 테스트를 작성하려면, 의존성이 역전되어 있어야 하는 경우가 생김 



## 테스트 3분류 

전통적인 테스트 3분류 
![](https://i.imgur.com/U5IL7fO.png)

헷갈리고 개발자마다 정의가 다름 


![](https://i.imgur.com/6Mmk89P.png)

**소형 테스트** 
- 단일 서버 
- 단일 프로세스
- 단일 스레드
- 디스크 I/O 사용해서 안됨
- Blocking call 허용 안됨 

**중형 테스트**
- 단일 서버
- 멀티 프로세스
- 멀티스레드 
-> H2 같은 테스트 DB를 사용할 수 있다. 

**대형 테스트**
- 멀티 서버
- E2E(End to End) 테스트 



## 테스트에 필요한 개념 

## 개념 
**SUT ( System under test )** : 테스트 하려는 대상 
![](https://i.imgur.com/GqE78jD.png)

**BDD ( given - when - then )**

**상호 작용 테스트** (Interaction test) 
: 대상 함수의 구현을 호출하지 않으면서 그 함수가 어떻게 호줄되는지 검증하는 기법 

**상태 기반 검증 vs 행위 기반 검증** 

**테스트 픽스처** 
: 테스트에 필요한 자원을 생성하는 것  
![](https://i.imgur.com/TdioMZl.png)

**비욘세 규칙**
- 구글에서 만든 규칙 
유지하고 싶은 상태나 정책이 있다면, 알아서 테스트를 만들어야 한다. 
<< 네가 나를 좋아했다면, (알아서)프러포즈를 했었어야지>> 

> 유지하고 싶은 상태가 있다면 전부 테스트로 작성해라. 그게 곧 정책이 된다.

ex) 유저 아이디가 이메일 형식이길 원한다면, 이메일 형태가 아닐 때 예외를 던지는 테스트를 작성하고, 마일리지 쿠폰이 5마원 이상일 때 사용가능하도록 만들고 싶다면 미만일때 예외를 던지는 테스트를 만들어라. 

<h2> 테스트는 정책이고 계약이다. </h2>
**Testabiltiy**
: 테스트 가능성, 소프트웨어가 테스트 가능한 구조인가? 

**test double (테스트 대역)**
- Dummy : 어떤 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체 
- Fake : 로컬에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체, 자체적인 로직이 존재한다. 
- Stub : 미리 준비된 값을 출력하는 객체 ( 보통 Mokito 프레임워크를 이용해 작성됨 )
- Mock : 메소드 호출을 확인하기 위한 객체, 자가 검증 능력을 갖춤. **사실상 테스트 더블과 동일한 의미로 사용됨** 




## 의존성 

> 컴퓨터 공학에서 말하는 의존성은 결합(Coupling)이고, 다른 객체의 함수를 사용하는 상태이다. 

A는 B를 사용하기만 해도 A는 B에 의존한다 할 수 있다. 

의존성 주입은 의존성을 약화시키는 것이지 의존성을 완전히 없애는 방법은 아니다. 의존성을 제거한다는 말은 객체 간의 협력을 부정하는 것이기 때문에 대부분의 디자인 패턴이나 설계는 의존성을 없애는 방향이 아닌 의존성을 약화시킬 수 있는지를 고민한 결과물이다. 

의존성을 주입받는게 왜 의존성의 강도를 약화시키는 것일까? New 는 사실상 하드코딩이다. 

**의존성 역전** 

> 의존성 역전과 의존성 주입은 다르다.
> 의존성 역전 (SOLID_DIP), 의존성 주입(DI)

의존성 역전이란? 
> 첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다. 
> 둘째, 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다. 

![](https://i.imgur.com/ETwVdif.png)

원래라면 Chef 에서 Beef 로 화살표가 들어왔는데, Meet 라는 인터페이스를 만들어서 Beef에서 화살표가 나가는 구조로 변경되었다. 의존성이 역전되었다. 

> 자바와 같은 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다. ...(중략)...
> 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다.

![](https://i.imgur.com/aPtuquU.png)

**의존성과 테스트**

테스트를 잘 할면 의존성 주입과 의존성 역전을 잘 다룰 수 있어야 한다. 

![](https://i.imgur.com/s2FOeTq.png)
![](https://i.imgur.com/5qRLbRX.png)

1. 의존성 주입으로 해결 
![](https://i.imgur.com/XhwM36U.png)
폭탄 돌리기가 될 수 있음 

2. 의존성 주입 + 의존성 역전으로 해결 

**테스트 가능성(testability)**

> 얼마나 쉽게 input을 변경하고, output을 검증할 수 있는가? 
![](https://i.imgur.com/P6uHWJT.png)

![](https://i.imgur.com/ArfEuGB.png)

호출자가 input 때문에 메서드의 내부 알고리즘을 확인함 -> 캡슐화 깨짐 



## 사전 탐색 

**빌더** 
> 생성자가 지나치게 많아지는 문제를 해결할 수 있는 유연한 해결책

테스트 데이터 빌더가 테스트의 표현력을 유지하고 변화에 탄력적으로 대응한다.
1. **새 객체를 생성할 때 문법적으로 지저분한 부분을 대부분 가려준다.**
2. 기본적인 경우 단순하게 하고 특별한 경우라도 그리 복잡하게 만들지 않는다.
3. **테스트 객체의 구조적인 변화로붜 테스트를 다시 한 번 보호한다.** 

< 정리 >
장점 
- 생성자를 하나로 관리할 수 있다.
- 긴 파라미터를 정리할 수 있다.
단점
- 종종 필요한 파라미터를 누락하는데, 컴파일러가 이를 캐치하지 못할 수 있다.

**엔티티**
> 도메인 엔티티, 영속성 객체, DB 엔티티 

에티티는 JPA랑 상관이 없다. 
경력을 더할수록 도메인 모델에 대한 이해가 쌓이면서 실제 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 같은 것이 아님을 알게 되었다. 

**도메인 엔티티**
> 소프트웨어에서 어떤 도메인이나 문제를 해결하기 위해 만들어진 모델
> 비즈니스 로직을 들고 있고, 식별 가능하며, 일반적으로 생명 주기를 갖는다. 

**DB엔티티**
> 데이터베이스 분야에서 개체 또는 엔티티라고 하는 것은 데이터베이스를 표현하려고 하는 유형, 무형의 객체로써 서로 구별되는 것을 뜻한다. 


