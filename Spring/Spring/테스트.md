# TEST 종류 

### SpringBootTest
- 전체 어플리케이션 컨텍스트를 로드하고 테스트
- 실제 어플리케이션과 가장 유사한 테스트 환경 
- `@SpringBootTest` 어노테이션 사용하여 테스트 클래스 지정 
- 모든 Bean 을 로드하므로 테스트가 느릴 수 있다. ( 프로젝트 규모에 따라 )
- 실제 웹 서버를 시작하고 모든 빈을 로드하므로 통합 테스트에 적합하다. 
### WebMvcTest
- 웹 애플리케이션의 MVC 계층을 테스트합니다. 컨트롤러, 필터 및 예외 처리기와 같은 웹 계층에 대해 테스트합니다.
- `@WebMvcTest` 어노테이션을 사용하여 테스트할 컨트롤러 클래스를 지정합니다.
- 웹 계층에 관련된 빈만 로드하므로 테스트가 빠릅니다.
- 실제 HTTP 요청을 보내지 않고, Spring MVC의 MockMvc를 사용하여 가짜 HTTP 요청을 생성하여 컨트롤러를 테스트합니다.
### DataJpaTest
- JPA 관련 기능을 테스트합니다. Repository 인터페이스와 관련된 빈들만 로드합니다.
- `@DataJpaTest` 어노테이션을 사용하여 테스트할 Repository 클래스를 지정합니다.
- 내장형 데이터베이스를 사용하여 테스트를 수행하므로 실제 데이터베이스에 의존하지 않습니다.
- JPA 엔터티와 관련된 CRUD 기능 및 쿼리 메서드를 테스트할 수 있습니다.
### RestclientTest
- RESTful 서비스를 호출하는 클라이언트를 테스트합니다. 외부 서비스 호출과 관련된 빈들만 로드합니다.
- `@RestClientTest` 어노테이션을 사용하여 테스트할 REST 클라이언트 클래스를 지정합니다.
- 외부 서비스를 실제로 호출하지 않고, MockRestServiceServer를 사용하여 외부 서비스의 응답을 모의(mock)합니다.
### MockBean
- 테스트할 클래스에서 특정 Bean을 모의(mock)하고자 할 때 사용한다.
- `@MockBean` 어노테이션을 사용하여 테스트할 클래스 내에서 모의할 Bean 지정 
- 실제 Bean 대신에 모의된 Bean이 주입되어 테스트 할 수 있다. 
> final 로 선언된 클래스나 메서드는 mock 을 만들 수 없다. 오버라이딩이 금지되기 때문 







# 테스트 프레임워크 

`JUnit` 

`org.junit.Assert.assertThat`
```java
public static <T> void assertThat(T actual, Matcher<? super T> matcher)
```

`AssertJ`

**차이점**

1. JUnit은 테스트 프레임워크로서 전체 테스트의 라이프사이클 관리와 테스트 메서드의 실행을 담당하며, AssertJ는 단언문(assertion) 라이브러리로서 **예상 결과와 실제 결과를 비교하는 데 사용**된다.

2. JUnit은 애너테이션을 사용하여 테스트 메서드를 정의하고 실행하는 데에 집중하고, AssertJ는 Fluent API를 사용하여 가독성이 뛰어난 단언문을 작성할 수 있습니다.

> Junit 의 경우 사용하고자 하는 메소드 ( ex lessThan, GreaterThan ) 들을 미리 import 하지 않으면 자동 완성을 해주지 못해 필요한 메소드를 공식문서에서 찾거나, 이름을 외워서 사용해야 하는 불편함이 있다. 
> 
> 또한 하나의 조건에 새로운 조건을 추가하여 검증하려면 allOf 라는 메소드로 기존 조건을 묶어줘야 한다. 
> (가독성 측면에서 떨어짐 )
> 
> 개인적으로 자동완성 부분에서 너무 불편하며 문법이 직관적인 느낌이 AssertJ보다 떨어진다.




# Mockito

> 자바에서 유닛 테스트 작성 시 사용되는 모의 객체를 생성하고 관리하는 라이브러리 






