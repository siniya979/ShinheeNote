# JWT 
> Json Web Token 

JWT를 암호화하여 당사자 간 보안을 제공할 수도 있지만 우리는 **_서명된_ 토큰에 중점**을 둘 것입니다.

## JWT 구조
- 헤더 ( Header )
- 페이로드 ( Payload )
- 서명 ( Signature )

> xxxxx.yyyyy.zzzzz


### 헤더 
> 헤더는 _일반적으로_ 토큰 유형(JWT)과 사용되는 서명 알고리즘(예: HMAC SHA256 또는 RSA)의 두 부분으로 구성됩니다.

```json
{
	"alg" : "HS256", 
	"typ" : "JWT" 
}
```

그런 다음 이 JSON은 **Base64Url로** 인코딩되어 JWT의 첫 번째 부분을 구성합니다.

### 페이로드 
> 토큰에서 사용할 정보의 조각들인 **클레임(Claim)***이 담겨 있다.

```JSON
{
	"sub" : "1234567890", 
	"name" : "John Doe", 
	"admin" : true          
}
```

- 암호화되지 않은 경우 페이로드 또는 헤더 요소에 민감 정보를 넣으면 안된다. 

### 서명 
> 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드

```JSON
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

위는 HMAC SHA256 알고리즘을 사용하는 경우의 예시이다. 

HAMC 는 시크릿 키를 포함하는 암호화 방식
SHA256 은 해쉬 방식 , 복호화 안됨 

로그인 요청을 하면 jwt 웹 토큰이 생성되고 클라이언트에게 반환해준다. 
클라이언트는 해당 토큰을 로컬 스토로지에 저장한다.

클라이언트가 인증이 필요한 요청을 보내면 서버는 해당 토큰이 유효한지 검증한다. 





## 세션
서버가 요청에 응답해서 html 을 반환해줄때 헤더 쿠키에 세션 id 를 담아서 준다. 
이건 최초 요청시에 만들어진다.
이후 요청시에는 웹 브라우저가 요청에 세션 아이디를 담아서 보낸다. 
사라지는 경우 
1. 서버에서 세션의 값을 날린다. (강제로 삭제한다)
2. 사용자가 브라우저를 닫아버리는 경우(종료) -> 브라우저가 들고 있는 세션값이 사라짐 그러나 서버는 세션 아이디를 아직 가지고 있음. (특정 시간이 지나면 사라짐)
3. 특정 시간이 지나면 세션 값이 서버쪽에서 사라진다. 

세션은 로그인 요청시 인증을 위해 많이 사용됨 
리퀘스트를 하면 서버는 저장소에 세션 아이디를 만든다. 
그리고 세션아이디마다 개별 저장소를 갖는다. 
서버가 응답할때 헤더에 세션아이디를 돌려준다. 
클라이언트의 웹브라우저에 세션아이디가 저장된다. 
로그인 요청을 한다. 아이디와 비밀번호를 서버에 보낸다.
서버는 db에 해당 데이터가 있는지 확인하고 정상이면 세션아이디가 갖는 저장소에 해당 유저정보를 저장한다. 
로그인이 성공하면 메인 페이지로 리턴한다(html파일)

인증이 필요한 요청을 하면 서버는 세션이 있는지 확인한다. 
서버는 세션 아이디로 유저 정보 데이터가 있는지 확인하고 있으면 로그인이 되어있다고 판단하고 요청 데이터를 조회해서 보내준다. 

세션의 단점
1.  동접자수가 많은 대형 사이트들은 서버가 많이 필요하다. ->  로드 밸런싱 
   1번 서버에서 세션을 만들었는데, 로드 밸런싱이 실행되서 다음 요청을 2번이 받으면 최초 요청으로 판단된다. 
   해결법들 )
   1. 스티킹 서버 - 2번 서버로 들어온 사람은 끝까지 2번 서버에서 요청을 처리하도록 한다. 
   2. 한 번 만들어지면 서버마다 세션을 복제한다.
   3. DB 에 세션값 저장 - 엄청 느려짐(IO에 접근을 매번 해야함으로)  DB는 다이렉트 접근이 불가능 
   4. 메모리 공유 서버를 만든다. 어떤 서버로 접근해도 같이 공유하기 때문에 상관없음 -> 이게 Redis. 





## TCP
![[Pasted image 20231030172856.png]]
OSI 7계층 
응용 : 오버워치-궁 사용  
프리젠테이션 : 암호화 / 압축 
세션 : 인증체크 
트랜스포트 : TCP 통신할지 UDP 통신할지 
네트워크 : IP 요구 (수신 대상 찾기)
데이터링크 : IP 다음 세부 기기 찾기 위함 
물리 : 실제 정비선, 강케이블 등 

TCP 는 수신 성공 여부 확인_신뢰성 ( ex 웹 )
UDP 수신 성공 여부 미확인 _비신뢰성 ex) 동영상 ( 프레임 한 두장이 손실되어도 문제 없음 . 좀 버벅여도 괜찮)




## CIA

정보보안 핵심 원칙 
- Confidentiality 기밀성 
- Integrity 무결성
- Availability 가용성

문서를 암호화하면 가용성이 깨져서 기밀성은 보장이 된다. 

1. 문서의 열쇠 전달 문제 
2. 누구로부터 왔는가? 

## RSA
> 공개키 암호화 중 하나. 

public key : 공개키  
private key : 개인키

키 하나 : 시멘트 키 (대칭키)

A가 어떤 메시지를 B에게 보내고자 한다
A는 B의 공개키로 메시지를 암호화해서 보낸다.
B는 본인의 개인키를 이용해서  B의 암호를 푼다. 

해커는 메시지를 탈취해서 B의 개인키가 없기 때문에 메시지를 읽을 수 없다. 

전자문서에서 서명으로 사용할 때 
A는 본인의 개인키로 잠근다. 
B는 A의 공개키로 해당 메시지를 열어볼 수 있다. 
이는 A가 보낸 것을 확신할 수 있게 한다 ( 즉 전자 서명 )
메시지가 열리면 -> 인증이 되었다는 것이고 아니면 인증이 안되었다는 것 


공개키 -> 개인키 ( 암호화 )
개인키 -> 공개키 ( 전자서명 )
## RFC

