# 11월 8일

![](https://i.imgur.com/ttjlaIR.png)

유저의 예약 취소 목록과 예약 노쇼 목록을 한 번에 불러와야 하는데, 코드를 짜면서 막혔다. 
ERD 를 보며 바로 떠올렸던 쿼리는 ( 예약과 예약 노쇼 조인 ) union ( 예약 + 예약 취소 조인 ) 이었는데, queryDsl은 Union을 지원하지 않는다. 

김영한 선생님이 실무에서 통계쿼리 말고 Union을 쓸 일이 별로 없다고 하는데 이런 경우는 어떻게 해결하는 것이 좋을까? 

다른 방법으로 생각난 것은 예약과 예약 노쇼를 아우터 조인으로 조인을 한뒤 결과물을 다시 취소 테이블과 아우터 조인하는 것이다. 
# 11월 14일 

예약과 하위 4개 테이블의 연관 관계를 어떻게 맺어야 할 지 전혀 감이 잡히지 않는다. 

단일 테이블 전략 vs 구체테이블전략 / 클래스 테이블 전략 

##  GPT 대답1 
### 1. **쿼리 성능과 복잡성**

- **하나의 테이블 사용**: 하나의 테이블에 모든 예약 정보를 저장하면 간단하게 구현되지만, 예약 정보가 많아질수록 성능이 저하될 수 있습니다. 특히, 상태가 'COMPLETED'인 예약 정보만 필요한 경우에도 모든 레코드를 스캔해야 합니다.
    
- **테이블 분할**: 예약 정보가 많을 때, 완료된 예약 정보만 따로 테이블을 만들면 쿼리 성능이 향상될 수 있습니다. 이는 'COMPLETED' 상태의 예약에 대한 쿼리가 해당 테이블에서만 이루어지기 때문입니다.
    

### 2. **데이터 일관성**

- **하나의 테이블 사용**: 하나의 테이블을 사용하는 경우, 예약 정보가 중복되지 않고 단일 테이블에서 관리되므로 데이터 일관성이 유지됩니다.
    
- **테이블 분할**: 테이블을 분할하는 경우, 두 테이블 간의 일관성을 유지해야 합니다. 예를 들어, 예약이 완료되면 두 테이블에 동시에 반영되어야 합니다.
    

### 3. **테이블 크기와 인덱싱**

- **하나의 테이블 사용**: 하나의 테이블을 사용하는 경우, 테이블이 크면 인덱싱 전략이 중요합니다. 적절한 인덱스를 사용하면 일부 성능 문제를 해결할 수 있습니다.
    
- **테이블 분할**: 테이블을 분할하면 작은 크기의 테이블에서 쿼리를 수행하므로 인덱싱이 더 효과적일 수 있습니다.
    

### 결론

- **적은 양의 데이터**: 예약 정보가 적은 경우에는 하나의 테이블로 충분할 수 있습니다.
    
- **많은 양의 데이터**: 예약 정보가 많아지면 성능 향상을 위해 테이블을 분할하는 것이 좋을 수 있습니다. 특히, 'COMPLETED' 상태의 예약 정보에 대한 쿼리 성능이 중요한 경우에는 테이블을 분할하는 것이 유리할 수 있습니다.
    
- **유지보수와 일관성**: 테이블을 분할할 경우, 두 테이블 간의 관리 및 일관성을 고려해야 합니다. 이에 따라 시스템의 유지보수 및 운영 부담이 증가할 수 있습니다.
    

최종적인 결정은 프로젝트의 특정 요구사항, 예상되는 데이터 양과 성능 요구사항 등을 고려하여 내리는 것이 좋습니다.

1. 왜 abstract 인가?
2. 컬럼이 모두 같은건 예약 테이블에 넣어버린다 
3. 확장을 고려해서 구체 테이블 전략으로 가자. 





## GPT 대답2
1. **단일 테이블에 모든 예약 정보 저장하기**: 단일 테이블에 상태에 따라 다양한 예약 정보가 저장되어 있을 경우, 성능 저하의 가능성이 있습니다. 하지만 예약 정보가 적고 인덱스가 잘 구성되어 있다면 문제가 되지 않을 수 있습니다. 또한 적절한 쿼리 최적화를 통해 일부 데이터만 선택적으로 가져오는 것도 가능합니다.
    
2. **상태에 따른 테이블 분리**: 상태에 따라 테이블을 나누는 방법도 고려할 수 있습니다. 예를 들어, "진행 중 예약 테이블"과 "완료된 예약 테이블"로 나누어 저장할 수 있습니다. 이렇게 하면 완료된 예약 목록을 가져올 때 성능 향상이 있을 수 있습니다. 단점은 테이블 간의 조인이 필요하다는 것이고, 코드를 유지보수하는 데 일부 어려움이 있을 수 있습니다.
    
3. **캐시 사용**: 자주 사용되는 데이터를 메모리에 캐시하면 데이터베이스에 대한 조회를 줄일 수 있습니다. 하지만 이는 일관성과 관련된 문제를 고려해야 합니다.
    

어떤 방법이 가장 적절한지는 프로젝트의 특정 요구사항, 예상되는 데이터 양, 사용 패턴 등을 고려하여 결정해야 합니다. 예를 들어, 초기에는 단일 테이블로 충분하지만 예약 데이터가 계속해서 늘어난다면 나중에 상태에 따라 테이블을 나누는 방법도 고려할 수 있습니다.




`@JoinColumn`의 `name` 속성은 외래 키(Foreign Key)의 이름을 지정하는 것이며, 이 이름은 참조하는 엔티티의 기본 키 컬럼과 일치해야 합니다. 만약 `User` 엔티티의 기본 키 컬럼이 `id`인데 `@JoinColumn(name = "user_id")`로 설정한다면 오류가 발생할 것입니다.